1.	数据库
		登录：mysql -uroot -p
		
	案例1-单表的crud---增删改查
	
	关系型数据库：二维表：实体-实体之间关系
	非关系型数据库：存放的是对象（redis）No-sql
	
	sql：管理数据库
	sql的分类：
		DDL:
			数据定义语言
			操作对象:数据库和表
			关键词：create alter drop
			
			操作数据库：
				创建数据库：create database 数据库名称
				删除数据库：drop database 数据库名称
				show databases;
				
			操作表：
				创建表：
					create table 表名(字段描述,字段描述)
						字段描述：字段名称 字段类型[约束]
					例如：	
						create table user(
							id int primary key auto_increment,
							username varchar(20)
						);
				修改表：
					格式：	
						alter table 表名...
					修改表名：
						alter table 旧表名 rename to 新表名；
						
					修改字段：
						alter table 表名 add [column] 字段描述；
					修改字段名：
						alter table 表名 change password pwd vachar(20);
					修改字段描述：
						alter table 表名 modiy 字段名称 字段类型 [约束];
					删除字段：
						alter table 表名 drop 字段名； 
					
				删除表：
					drop table 表名； 
				常用命令：
					切换数据库：use 数据库名称
					查看所有表：show tables;
					查看表结构：desc 表名
					查看建表语句：show create table 表名；
		DML:
			数据操作语言
			操作对象：记录(行)
			关键词：
				insert update delete
			插入：
				格式1：
					insert into 表名 values(字段值1，字段值2，...,字段值n);
					注意：	
						默认插入全部字段，
						必须保证values 后面的内容的类型和表结构中的一致
						若字段类型为数字，可以省去引号
					例如：
						insert into user values(1,'tom')
						insert into user values('2','tom')
						insert into user values('3')-----错误的
				格式2：
					insert into 表名(字段名1，字段名2..) values (字段值1，...)  
					注意：	
						插入指定字段，
						保证value后面的内容和顺序和表名后面的字段的类型和顺序保持一致
					例如：	
						insert into user (username,id) values ('jack',4);
						insert into user (username) values ('jack',5); ---error
			
			修改：
				格式：
					update 表名 set 字段名=字段值，字段名2=字段值2..[where 条件];
					例如：	
						update user set username='jerry' where username='jack';---或者id=...
			删除：	
				格式：
					delete from 表名 [where 条件]
					删除有物理删除和逻辑删除（常用），
					逻辑删除一般会在表中添加一个字段，（isDel 若值为1 ，代表删除了。若为0，代表没有删除，此时删除操作变成了更新操作）
				例如：
					delete from user where id = '2';
		DQL:
			数据查询语言（非官方）
			操作记录
			关键词：select
			格式：
				select ... from 表名 where 条件 group by 分组字段 having 条件 order by 排序字段 asc|desc
			执行顺序：
				1.确定数据来自哪张表 from
				2.是否主要筛选 where
				3.是否需要分组 group by
				4.分组后是否需要筛选 having
				5.是否需要排序 order by
				6.确定显示哪些数据 select
			
			假设表：
				创建商品表：
				create table products(
					pid int primary key auto_increment,
					pname varchar(20),
					price double,
					pnum int,
					cno int,
					pdate timestamp
				);
				insert into products values (null,'泰国大榴莲',98,12,1,null);
			
			
			查询：
				1.查询所有的商品
					select * from products;
				2.查询商品名和商品价格.	
					select pname,price from products;
				3.查询所有商品都有那些价格.  --distinct去重
					select distinct price from products;					
				4.将所有商品的价格+10元进行显示.(别名)
					-----给列起别名 格式： 字段名 [as] 别名
					select price+10 from products;
					select price+10 新价格 from products;
					select price+10 '新价格' from products;  --有空格时必须加‘’
				条件查询：
					1.查询商品名称为香蕉的商品所有信息：
						SELECT * FROM `products` where pname='香蕉'
					2.查询商品价格>60元的所有的商品信息:
						SELECT * from `products` WHERE price>10
					3.查询商品名称中包含”新”的商品
						------模糊匹配
						------格式：字段名 like "匹配规则"
							匹配内容：
								"啊"    值为啊
								"%啊"   值以啊结尾
								"啊%"   值以啊开头
								"%啊%"  包含啊
							匹配个数：
								"_"   几个下划线代表几个位置
						
					4.查询价格为38,68,98的商品
						SELECT * FROM `products` where pprice in (30,60,90);
					
					where 后的条件写法：
						* > ,<,=,>=,<=,<>--不等于
						* like 使用占位符 _ 和 %  _代表一个字符 %代表任意个字符. 
						* in在某个范围中获得值.
						* between 较小值 and 较大值
					
			排序查询:
				1.查询所有的商品，按价格进行排序.(asc-升序,desc-降序)
					select * from products order by price desc;
				2.查询名称有新的商品的信息并且按价格降序排序.
					select * from `products` where panme like "%新%" order by price desc;


			聚合函数: 
				----对列进行计算，返回值是一个,忽略null值   上面是对行进行计算
				
				* sum(),avg(),max(),min(),count();
					
				1.获得所有商品的价格的总和：
					select sum(price) from products;
				2.获得商品表中价格的平均数：
					select avg(price) from products;
					---round(值，保留小数位数)
					select round(avg(price),2) from products;
				3.获得商品表中有多少条记录：
					select count(*) from products;
					

			分组：使用group by
				1.根据cno字段分组，分组后统计商品的个数.
					select cno,count(*) from products group by cno;
				2.根据cno分组，分组统计每组商品的总数量，并且总数量> 200;
					select cno,sum(pnum) from products group by cno;
					select cno,sum(pnum) from products group by cno having sum(pnum)>200;
					
					注意：
						where 和having区别：
							1.where是对分组前的数据进行过滤，having 是对分组后的数据进行过滤						
							3.where 后面不使用聚合函数，having可以
			/////////////////////////////
		数据类型：	
			Java			MySQL
			byte			tinyint
			short			smallint
			int 			int(!)
			long			bigint
			char/String 	varchar(!)|char
							varchar:可变长度 mysql方言 varchar(20) 存放abc 占三个
							char: 固定长度  char(20) 存放abc 占20个
			boolean			tinyint|int
			float|double 	float|double
							double（5,2）该小数长度为5个，小数占2个
			java.sql.Date   	   date日期
			java.sql.Time		   time时间
			java.sql.TimeStamp 	   timestamp(!)   时间戳 若给定null 数据库存放当前时间
								   datetime(!)	日期+时间（数据库独有 java没有）
			java.sql.Clob(长文本)  text(mysql 方言)
			java.sql.Blob(二进制)  blob
		
		约束：
			为了保证数据的有效性和完整性
			mysql中常用约束：
				主键约束（primary key）,唯一约束（unique）,非空约束（not null），外键约束（foreign key）
				
				primary key：唯一 非空
				------一张表只能有一个主键，这个主键可以包含多个字段
					1.建表的同时添加约束  格式：字段名称 字段类型 primary key
						最常用，只能给一个字段添加主键
					2.建表的同时在约束区添加约束 格式： 所有的字段声明完成之后 primary key(字段1，字段2)
						2 3 可以给多个字段
					create table pk01(
						id int,
						username varchar(20),
						primary key(id，username)
					);
					3.建表之后，修改表结构添加约束
						create table pk02(
						id int,
						username varchar(20),
					);
					
					alter table pk02 add primary key（字段1，字段2...）
						多个字段是主键被叫做联合主键，只有都一样的时候，才看做一条记录
				
				唯一约束（了解）：
				---------唯一 对null不起作用
					1 2 3与上面相同
					create table un(
						id int unique,
						username varchar(20) unique,   /////和上面的不同，可以给多个字段添加 
					);
				非空约束（了解）：
					create table nn(
						id int not null,
						username varchar(20) not null
					);
			///////////////////////////////////////
			truncate 清空表
				格式：	
					truncate 表名;  干掉表，重新创建一张空表
				和delete from 区别：
					delete 属于DML语句，truncate属于DDL语句
					delete 逐条删除    truncate干掉表，重新创建一张空表
			auto_increment:
				要求：
					1.被修饰的字段支持自增  一般为int
					2.被修饰的字段必须是一个key,一般是primary key 
			
		
		DCL:
			数据控制语言
			操作对象：用户 事务 权限
	
2.	案例2-创建多表 ，可以描述表与表之间的关系
	需求：
		网上商城
		实体：用户 商品 分类
	常见关系：
		一对多：用户-订单，分类-商品
		多对多：订单-商品，学生-课程
		一对一：
	ER图描述实体与实体之间的关系 --实体 属性 关系
	
	一对多：
		一方称之为主表或一表，多方称之为从表，为了表示一对多的关系，一般会在多表的一方添加一个字段，字段名称建议为（主表的名称_id）,字段类型一般和主键的类型保持一致，称这个字段为外键
		
		垃圾数据：
			用户删了，订单里还有；
			为了保证数据的有效性和完整性，在多表的一方，添加外键约束（不是必须的，也可以通过java程序控制），外键可以是null
			格式：
				alter table 多表名称 add foreign key （外键名称）reference 主表名称（主键）;
			添加了外键约束之后，有如下特点：
				1.主表中不能删除从表中已引用的数据
				2.从表中不能添加主表中不存在的数据
	
	多对多：
		在开发中引入一张中间表，在中间表中存放两张表的主键，一般还会将这两个主键设置成中间表的联合主键（也可以不），，将多对多拆分成两个一对多
		
		为了保证数据有效性和完整性，在中间表上添加两个外键约束即可（不是必须的，也可以通过java程序控制）
	一对一：	
		身份证-人  
		（1）将两个实体合二为一
		（2）在一个表上将这个表的主键设置成外键且添加外键约束
	
3.	案例3-多表查询
		内连接
		外链接
		子查询
	
	笛卡尔积：多张表无条件的联合查询。没意义

	练习:（1）（2）
		查询用户的订单,没有订单的用户不显示
			SELECT user.*,orders.*
			FROM `user`,orders
			WHERE user.id=orders.user_id
			
			SELECT user.username,orders.*
			FROM `user`inner join orders
			ON user.id=orders.user_id
		查询所有用户的订单详情
			左外连接，所有用户---用户在左
				SELECT user.*,orders.*
				FROM user LEFT JOIN orders
				ON user.id=orders.user_id
		查询所有订单的用户详情
			右外连接，--所有订单，订单在右
				SELECT orders.*, user.*
				FROM `user` RIGHT JOIN orders
				ON user.id=orders.user_id
	（1）内连接：
			格式1：显式的内连接
				select a.*,b.* from a [inner] join b on ab连接的条件
			格式2：隐式的内连接
				select a.*,b.* from a,b where ab连接的条件
				
	（2）外连接（重要）
			左外连接：
				select a.*,b.* from a left [outer] join b on 连接条件;
				先展示join左边的（a）表的所有数据，根据条件关联查询join 右边的表（b）,符合条件则展示出来，不符合以null值展示。
			右外连接：
				select a.*,b.* from b right [outer] join a on 连接条件;
				先展示join右边的（a）表的所有数据，根据条件关联查询join 左边的表（b）,符合条件则展示出来，不符合以null值展示。
	（3）子查询（重要）
			给表起别名：表 [as] 别名
	练习:（3）
		查看用户为李四的订单详情
			SELECT orders.*  
			from orders
			WHERE user_id =(
				SELECT id 
				from `user`
				WHERE username = '李四'
			)
		查询出订单的价格大于300的所有用户信息。
			SELECT user.*
			FROM `user`
			WHERE id in(
				SELECT user_id
				FROM orders
				WHERE totalPrice>300
			)
		查询订单价格大于20的订单信息及相关用户的信息	
			内连接：
				SELECT orders.*,user.*
				FROM orders ,`user`
				WHERE orders.user_id=user.id AND orders.totalPrice>20 
			子查询：
				SELECT user.*,tmp.*
				FROM user,
					(SELECT orders.* 
					FROM orders 
					WHERE totalPrice>20 )AS tmp
				WHERE `user`.id=tmp.user_id
4.	JDBC 
		java操作数据库，一套接口，
		驱动----->（jdbc的一套实现类 由数据库厂商提供)
		jdbc作用：
			连接数据库
			发送sql语句
			处理结果
		jdbc操作步骤：
			1.导入驱动jar 包（驱动）
			2.注册驱动 
				Class.forname("com.mysql.jdbc.driver")
			3.	获取连接
					有时候出现中文字符问题：
					Connection conn =DriverManager.getConnection("jdbc:mysql://localhost:3306/day07?useUnicode=true&characterEncoding=utf8", "root", "123456");
					或者已经将my.ini修改 修改好了
			4.编写sql
			5.创建语句执行者
			PreparedStatement st = conn.prepareStatement(sql)
			6.设置参数
				st.setXXX()
			7.执行sql
				ResultSet rs= st.execuQuery();
				int i = st.execuUpadate()
			8.处理结果
				if(rs.next()) re.getXXX(int | string)
			9.释放资源
				
	案例1-通过jdbc 完成单表的crud操作
		IDE设置；
		使用junit单元测试
			1.方法是 public void xxx{}
			2.在方法上添加 @Test
			3. ctr+1 快速锁定错误
			4.在方法上右键 run as --》junit就可以执行方法 （底层是main）

5.	JDBC-api:
	所有的包 都是java.sql 或者javax.sql
	DriverManager:管理了一组jdbc的操作类
		常用方法：	
			了解：注册驱动
				static void registerDriver(Driver driver):
				通过查看com.mysql.jdbc.Driver的源码， 有如下：
					static {
						try {
							java.sql.DriverManager.registerDriver(new Driver());
						} catch (SQLException E) {
							throw new RuntimeException("Can't register driver!");
						}
				驱动注册了两次，我们只需将静态代块执行一次，类被加载到内存会执行静态代码，并且只执行一次，现在只需将类加载到内存即可：
					方式1：掌握
						Class.forName("全限定名")  //包名+类名 com.mysql.jdbc.Driver
					方式2：
						类名.class;
					方式3：
						对象.getClass() ;
			掌握：获取连接
				static Connection getConnection(String url, String user, String password)
					参数1：
						协议：数据库类型:子协议：参数
						jdbc:mysql://localhost:3306/数据库名称
					参数2 3：账号密码
	Connection 连接 接口
		常用方法：
			获取语句执行者：
				*Statement createStatement() 普通的语句执行者 会出现sql注入
				PreparedStatement prepareStatement(String sql)  ：获取预编译语句执行者
				*CallableStatement prepareCall(String sql)：获取调用存储过程的语句执行者
				
			了解：
				setAutoCommit（false） 手动开启事务
				commit():提交事务
				rollback():事务回滚
	Statement:语句执行者 接口
	PreparedStatement:预编译语句执行者 接口
		常用方法：
			(1)设置参数：
				setXXX(int 第几个问号,Object 实际参数)；
					常见的方法:
						setInt
						setString
						setObject
			(2)执行sql:
				ResultSet executeQuery():执行r语句  返回值：结果集
				int execuUpdate():执行cud语句 返回值：影响的行数
	ResultSet ：结果集 接口
		执行查询语句之后返回的结果
		常用方法：	
			boolean next():判断是否有下一条记录，若有返回true 且将光标移到下一行，若没有，则返回false
			
			获取具体内容：
				getXXX(Int | String)
					若参数为Int ：第几列
					若参数为String： 列名
				例如：
					获取cname的内容可以通过
						getString（2）
						getString("cname")
				常用方法：
					getInt
					getString  也可以获取int值
					getObject	可以获取任意值
			
///////////////////////////////////////////////////
	***快捷键总结：
	ctrl+shift+f :格式化代码
	ctrl+o：整理包
	alt+/ ：提示
	ctr+1：快速锁定错误
	alt+shift+a: 块编辑  不要用中文输入法
	ctrl+2 L 
	ctrl+shift+X :变大写
	ctrl+shift+y:变小写
	alt+ctrl+向下： 向下复制一行
	shift+enter :向下添加一个空行
	ctrl+d：删除一行
	alt+向下:向下移动一行 
	ctrl+o 调出他的所有的方法
////////////////////////////////////////////////////////
	常见的配置文件格式：
		1.properties
			key=value;  //里面都是字符串 不用再加引号
			回车 之前不能加空格
		2.xml
		
	若 配置文件为properties,并且放在src目录,可以通过ResourceBundle工具快速获取里面的配置信息
	步骤：
		1.获取ResourceBundle 对象：
			static ResourceBundle getBundle("文件名称不带后缀名")
		2.通过ResourceBundle 对象获取配置信息：
			String getString(String key)：通过执行key获取指定value 
			
6.	案例2-通过连接池（数据源）优化操作
		使用jdbc的时候 每操作一次都需要获取连接（创建）  用完之后把连接释放掉（销毁） 通过连接池来优化crud操作
		技术：连接池
			管理数据库的连接
			作用：
				可以提高项目性能，
			就是在连接池初始化的时候存入一定数量的连接 用的时候通过方法获取 不用的时候归还连接即可
			
			所有的连接池必须实现一个接口，javax.sql.DataSource接口
			
			获取连接的方法：
				Connection	getConnection()
			归还连接的方法就是 释放资源的方法，
				Conn.close();
			
			
		常用的连接池：
		DBCP(了解) ：
			apache
			步骤:
			1.导入jar包（dbcp.jar ,pool.jar）
			2.使用API
				a.硬编码
					//	创建连接池
					BasicDataSource ds = new BasicDataSource();
					//	配置信息等
					ds.setDriverClassName("com.mysql.jdbc.Driver");
					ds.setUrl("jdbc:mysql:///day07?useUnicode=true&characterEncoding=utf8");
					ds.setUsername("root");
					ds.setPassword("123456");
				b.配置文件
					Properties prop = new Properties();
					prop.load(new FileInputStream("src/dbcp.properties"));
					DataSource ds =new BasicDataSourceFactory().createDataSource(prop);
			没有自动回收的功能		
		C3P0(❤)：
			hibernate spring使用 
			有自动回收空闲连接的功能
			步骤：	
				1.导包
				2.使用API
					a.硬编码
						new ComboPooledDataSource()
					b.配置文件
						配置文件的名称：c3p0.properties 或者 c3p0-config.xml
						配置文件的路径：src下
						
						编码：
							new ComboPooledDataSource() 就可以 //使用默认的配置
							new ComboPooledDataSource(String configName)//使用命名的配置，若找不到使用默认的
						
						
		增强方法：
			1.继承  需要父类的源码 局限
			2.装饰者模式 （静态代理）
				步骤：
					1.装饰者和被装饰者实现同一个接口 或继承同一个类
					2.装饰者要有被装饰者的引用      (通过构造器 引用写成被装饰者的父类，这样不仅可以装饰这个 被装饰的层级的)
					3.对需要增强的方法进行增强
					4.对不需要加强法人方法调用原来的方法
			3.动态代理
			
7.	static 关键字：
		1.static 关键字的用途：
			方便在没有创建对象的情况下来进行调用（方法/变量）。
			(1)static方法：
				静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。
			(2)static变量
				静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化
			(3)static代码块
				static关键字还有一个比较关键的作用就是用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照
				static块的顺序来执行每个static块，并且只会执行一次。
				
8.	案例3-使用 dbutils完成crud
		dbutils: apache 的一个工具类
				使用步骤：
					1.导入jar包（commons-dbutils-1.4.jar）
					2.创建一个queryRunner类
						queryRunner 作用：操作sql
							构造方法  new QueryRunner(DataSource ds);
					3编写sql  （只能带问号的那种）
					4.执行sql	
						query() r操作
						update()  cud操作
		核心类：
			QueryRunner: 操作sql语句
				构造器：
					new QueryRunner(DataSource ds);
				常用方法：
					query() r操作
					update()  cud操作 在update里可以找到？设置参数的方法
			Dbutils: 类 释放资源  控制事务
				closeQuietly(conn):内部处理了异常
				commitAndClose(Connection conn): 提交事务 并释放连接
			ResultSetHandler:封装结果集  接口  查询
				9个实现类：
					ArrayHandler, 将查询结果的第一条记录封装成数组 返回
					ArrayListHandler,  将查询结果的每一条记录封装成数组，将每一个数组放入list返回
					❤❤BeanHandler：将查询结果的第一条记录封装成指定的bean对象，返回
					❤❤BeanListHandler, 将查询结果的每一条记录封装成指定的bean对象，将每一个bean对象放入list返回
					ColumnListHandler,将查询结果的指定一列发入list  返回
					KeyedHandler,
					MapHandler, 将查询结果的第一条记录封装成map,字段名为key 值为value 返回
					❤MapListHandler, 将查询结果的每一条记录封装成map集合, 将每一个map集合放入list返回
					❤ScalarHandler：针对于聚合函数 例如 count() 返回long值
						：map.getClass().getName() 可以返回map类型 

9.	xml:
		可扩展的标签语言
		标签自定义
		作用：存储数据 （配置文件）
		书写规范：
			1.区分大小写
			2.必须有一个根标签			
			3.标签必须关闭
				<xx></xx>
				<xx/>
			4.属性必须用引号引起来
				<xx att="value"/>
			5.标签体中的空格或者换行或者制表符等内容都是作为数据存在的
			6.特殊字符必须转义   <  >  &
			满足以上规范的文件称之为是一个格式良好的xml文件  可以通过浏览器浏览
		后缀名 .xml
		组成：
			声明：第一行 顶格写
			元素（标签）：
				<xx></xx>
				<xx/>
				要求：
					1.必须关闭
					2.标签名中不能 xml Xml XML 等开头
					3.标签名不能出" " 和:等特殊字符
					
			属性：
				格式：
				<xx 属性名="属性值"></xx> 
				属性必须用引号引起来
			注释:<!-- -->
			CDATA:
				xml文件特殊字符必须转义  
					1.---------三部分 例如<a> 写为  &lt;a&gt; 
					2.<![CDATA[ 可以原样输出的。。。。。]]>	
		
		xml解析：
			解析方式：
				1.sax 逐行解析 只能查询
				2.dom 一次性将文档加载到内存 形成dom树 可以对dom树进行crud
			解析技术：			
			  常见的解析开发包：
			  JAXP：sun公司提供支持DOM和SAX开发包
			  JDom：dom4j兄弟
			  jsoup：一种处理HTML特定解析开发包
			    ❤dom4j：比较常用的解析开发包，hibernate底层采用。
				
			dom4j技术进行查询操作：
				使用步骤：
					1.导入jar包
					2.创建一个核心对象 SAXReader
						new SAXReader
					3.将xml文档加载到内存中形成一颗树
						Document doc=reader.read(文件名)
					4.获取根节点
						Element root = doc.getRootElement();
					5.通过根节点就可以获取其他节点（文本节点 属性节点 元素节点）
						获取所有子元素
							List<Element> list = root.elements()
						获取元素的指定属性内容
							String value = root.attributeValue("属性名")
						获取子标签标签体 ：遍历list 获取到每一个子元素
							String text = ele.elementText("子标签名称")
				缺点是 若想找到一个嵌套深的 则需要一步步获取	 
					
			xpath 解析技术：
				依赖于dom4j
				使用步骤：
					1.导入jar包(dom4j 和 jaxen-1.1-beta-6.jar)
					2.加载文件到内存
					3.使用API
						selectNode("表达式")
						selectSingleNode("表达式")
				表达式的写法：
				  /  从根节点选取。
				  //  从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置
				  获取属性的值：
					例如 //AAA[@属性名="属性值"]
					
				
					
					
					
					
					
10.	案例1-编写配置文件 编写一个服务器软件 按照指定的全限定名 根据路径 让服务器创建这个对象，调用指定的方法
	解析xml
	通过全限定名创建一个对象 调用方法 ----------反射
	
11.	反射
	1.获取对应的class对象
		方式1：❤
			Class clazz = Class.forname("全限定名")
		方式2：
			Class clazz = 类名.Class();
		方式3：
			Class clazz = 对象.getClass();
		{
			Class类也是类的一种，与class关键字是不一样的。
			手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中。
			每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。

			Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载
			Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要。

		} 	
	2.通过Class对象创建一个实例对象(相当于 new 类())
		Object clazz.newInstance();  
	3.通过Class 对象 获取一个方法
		Method method = clazz.getMethod(“方法名”，Class .... param)
			param为参数类型
	4.让方法执行
		method.invoke(a,10,20)
		method.invoke(Object 实例对象，Object ...参数)  ==a
			Object ...参数 ：该方法运行时需要的参数   ==10,20	